# Inputs, Assumptions, and Scenarios – Advanced Upgrade Path (AgentZero / Pathways ABM)

This document describes an advanced upgrade path for how the AgentZero web app handles inputs, assumptions, and scenarios, building on the simpler path (renamed tabs, timestep indicator, heuristic grouping, and base-year agent views).

The focus is on making the model **legible, explorable, and explainable** for energy transition stakeholders, while keeping implementation incrementally adoptable and backward compatible with the existing `WebBundle` and engine.

---

## 0. Current State and Design Principles

**Current relevant data structures (simplified):**

```ts
export interface AssumptionRow {
  param: string;
  region: string | null;
  sector: string | null;
  tech: string | null;
  year: number;
  value: number;
  unit: string;
  source: string | null;
  uncertainty?: {
    low: number;
    high: number;
    distribution: 'uniform' | 'normal' | 'triangular';
  };
}

export interface ScenarioDiffRow {
  param: string;
  region: string | null;
  sector: string | null;
  tech: string | null;
  year: number;
  baseline_value: number;
  scenario_value: number;
  delta: number;
  delta_pct: number;
  rationale: string | null;
}

export interface AgentConfig {
  agent_id: string;
  agent_type: AgentType;
  region: string;
  sector: string | null;
  tech: string | null;
  initial_capacity: number;
  horizon: number;
  discount_rate: number;
  decision_rule: string;
  vintage: number;
  params: Record<string, unknown>;
}

export interface TimeseriesRow {
  year: number;
  region: string;
  commodity: string;
  price: number;
  demand: number;
  supply: number;
  emissions: number;
  scenario_id: string | null;
  assumptions_id: string;
  run_id: string;
}

export interface Driver {
  factor: string;
  contribution: number;
  direction: 'positive' | 'negative' | 'neutral';
  explanation: string;
  related_params: string[];
  related_agents: string[];
}

export interface WebBundle {
  manifest: Manifest;
  summary: Summary;
  timeseries: Timeseries;
  agents: Agents;
  agent_traces: AgentTraces;
  assumptions_used: AssumptionsUsed;
  scenario_diff?: ScenarioDiff;
  drivers: Drivers;
}
```

**Design principles:**

- **Lightweight metadata and graphs** generated by the engine and consumed by the web app.
- **Incremental adoption**: each piece is optional and versioned; old bundles remain valid.
- **Shared schemas**: keep parameter and graph schemas in code, generate both back-end and front-end types from them when possible.
- **User-centered**: start with what users ask — "what drives this result?", "what if we change this lever?", "what does this parameter mean?".

---

## 1. Parameter Metadata Schema

### 1.1 Goals

- Classify each parameter (`AssumptionRow.param`) into:
  - **Category**: `demand`, `physics`, `policy`, `techno-economic`.
  - **Units** and valid ranges.
  - **Affected entities**: agents, commodities, outputs.
  - **Direction of effect** on key outputs (emissions, prices, capacity, etc.).
- Power consistent UI grouping, tooltips, and scenario lever selection.
- Provide the backbone for dependency graphs, scenario design, and documentation.

### 1.2 Storage and Versioning

Introduce a machine-readable metadata file, e.g.:

- `assumptions/parameter-metadata.yaml` (source of truth in engine repo).
- Optionally include a subset in the `WebBundle` for the given run.

Extend `Manifest` with an optional field:

```ts
export interface Manifest {
  // existing fields...
  schema_versions: {
    assumptions: string;
    scenario: string | null;
    results: string;
    parameter_metadata?: string; // new
  };
}
```

And in `WebBundle` (Web-only convenience):

```ts
export interface WebBundle {
  // existing fields...
  parameter_metadata?: ParameterMetadata[];
}
```

### 1.3 Parameter Metadata Schema (YAML)

A light schema that can be used directly in YAML/JSON:

```yaml
# parameter-metadata.yaml

- id: carbon_price
  label: Carbon price
  description: >
    Exogenous carbon price applied per tonne of CO2 emitted by emitting agents.
  category: policy              # 'demand' | 'physics' | 'policy' | 'techno-economic'
  unit: USD/tCO2
  dimensions:                   # which indices can vary
    - region
    - year
  default_scope:                # typical dimension defaults
    region: 'all'
    sector: null
    tech: null
  affected:
    agents:
      - ElectricityProducer
      - IndustrialConsumer
    commodities: []
    outputs:
      - emissions
      - price
  direction_of_effect:          # relative to baseline
    emissions: negative         # higher carbon_price → lower emissions
    price: positive             # higher carbon_price → higher prices
    capacity: neutral
  typical_range:
    min: 0
    max: 500
    recommended_step: 10
  ui:
    group: Policy
    order: 10
    is_scenario_lever: true
    slider:
      min: 0
      max: 300
      step: 5

- id: demand_elasticity
  label: Demand elasticity to price
  description: >
    Price elasticity of demand (percentage change in demand for 1% change in price).
  category: demand
  unit: dimensionless
  dimensions:
    - region
    - sector
  affected:
    agents:
      - IndustrialConsumer
    commodities:
      - electricity
  direction_of_effect:
    demand: negative            # more negative → lower demand when prices rise
    emissions: negative
  typical_range:
    min: -2
    max: 0
  ui:
    group: Demand
    order: 5
    is_scenario_lever: true
```

### 1.4 TypeScript Representation

Front-end TS types, ideally generated from the YAML schema:

```ts
export type ParamCategory =
  | 'demand'
  | 'physics'
  | 'policy'
  | 'techno-economic';

export type AffectedOutput =
  | 'emissions'
  | 'price'
  | 'capacity'
  | 'demand'
  | 'supply'
  | 'investment';

export interface ParameterMetadata {
  id: string; // matches AssumptionRow.param
  label: string;
  description: string;
  category: ParamCategory;
  unit: string;
  dimensions: Array<'region' | 'sector' | 'tech' | 'year'>;
  default_scope?: {
    region?: string | 'all' | null;
    sector?: string | null;
    tech?: string | null;
  };
  affected?: {
    agents?: AgentType[];      // from index.ts
    commodities?: string[];
    outputs?: AffectedOutput[];
  };
  direction_of_effect?: Partial<Record<AffectedOutput, DriverDirection>>;
  typical_range?: {
    min?: number;
    max?: number;
    recommended_step?: number;
  };
  ui?: {
    group?: string;
    order?: number;
    is_scenario_lever?: boolean;
    slider?: {
      min?: number;
      max?: number;
      step?: number;
      scale?: 'linear' | 'log';
    };
  };
}
```

### 1.5 UI Usage

- **Inputs & Assumptions tab**:
  - Group rows by `ui.group` and `category` instead of only heuristic name matching.
  - Show `label` and `description` on hover or as expandable rows.
  - Use `unit` and `typical_range` for value formatting and validation.
- **Scenario Levers tab (Scenario Diff)**:
  - Only show parameters with `ui.is_scenario_lever === true`.
  - Use `ui.slider` definitions to render sliders/toggles, tied to time (see §3).
- **Tooltips in Results**:
  - When hovering a result metric (e.g., electricity price in 2035), use `affected.outputs` and the dependency graph to highlight related parameters (see §2).

---

## 2. Dependency Graph: Assumptions → Agents → Results

### 2.1 Goals

- Explicit, machine-readable graph connecting:
  - **Assumptions/parameters** (`AssumptionRow.param`)
  - **Agents** and their decision rules (`AgentConfig`, `AgentTraces`)
  - **Results** (`TimeseriesRow`, `Summary`, `Driver`)
- Support queries like:
  - "Which parameters feed into this output (e.g., 2035 electricity price)?"
  - "Through which agents does this carbon price influence emissions?"

### 2.2 Data Model

Introduce a new optional structure in `WebBundle`:

```ts
export type DependencyNodeType =
  | 'parameter'
  | 'agent_type'
  | 'agent'
  | 'commodity'
  | 'timeseries_metric'
  | 'summary_metric'
  | 'driver_factor';

export type DependencyRelation =
  | 'feeds'
  | 'influences'
  | 'governs'
  | 'aggregates_to'
  | 'derived_from';

export interface DependencyNode {
  id: string;                    // globally unique within the graph
  type: DependencyNodeType;
  label: string;
  meta?: Record<string, unknown>;
}

export interface DependencyEdge {
  source: string;                // node id
  target: string;                // node id
  relation: DependencyRelation;
  sign?: DriverDirection;        // 'positive' | 'negative' | 'neutral'
  weight?: number;               // relative influence (0-1) or contribution score
  years?: number[];              // years for which this edge is relevant
}

export interface DependencyGraph {
  nodes: DependencyNode[];
  edges: DependencyEdge[];
}

export interface WebBundle {
  // existing
  dependency_graph?: DependencyGraph; // new
}
```

**Node conventions:**

- `parameter` nodes:
  - `id = "param:<param_id>"` (e.g., `param:carbon_price`).
- `agent_type` nodes:
  - `id = "agent_type:<type>"`.
- Aggregate `agent` nodes:
  - `id = "agent:<type>:<region>:<tech>"` (aggregated to avoid explosion).
- `commodity` nodes:
  - `id = "commodity:<name>"`.
- `timeseries_metric` nodes:
  - `id = "ts:<metric>:<commodity>:<region>:<year>"`  
    Example: `ts:price:electricity:EU:2035`.
- `summary_metric` nodes:
  - `id = "summary:<field>"`  
    Example: `summary:total_emissions`.
- `driver_factor` nodes:
  - `id = "driver:<factor>"` (from `Driver.factor`).

**Edge conventions (examples):**

- `parameter → agent_type` (`relation: 'governs'`):
  - Carbon price affects decision rule / NPV for `ElectricityProducer`.
- `parameter → commodity` (`relation: 'influences'`):
  - Demand elasticity affects electricity demand.
- `agent_type → timeseries_metric` (`relation: 'feeds'`):
  - Producers feed into supply and price.
- `timeseries_metric → summary_metric` (`relation: 'aggregates_to'`):
  - Annual emissions aggregate to `Summary.cumulative_emissions`.
- `parameter → summary_metric` (`relation: 'influences'`):
  - If discovered via sensitivity or `Driver`.
- `parameter → driver_factor` and `driver_factor → summary_metric`:
  - Use `Driver.related_params` and `Driver.factor`.

### 2.3 Graph Construction Strategy

Use a combination of **static metadata** and **runtime instrumentation**:

1. **Static from metadata:**
   - From `ParameterMetadata.affected` fields, create coarse-grained edges:
     - `parameter → agent_type` based on `affected.agents`.
     - `parameter → commodity` based on `affected.commodities`.
     - `parameter → summary_metric` based on `affected.outputs`.

2. **Runtime from engine (optional, richer):**
   - When the engine resolves a parameter value for a given agent / decision step:
     - Log an edge `parameter → agent` with year.
   - When agents produce supply/emissions:
     - Log `agent → timeseries_metric`.
   - When computing summary metrics:
     - Log `timeseries_metric → summary_metric`.

   This can be stored in an internal log and reduced to a coarser graph (aggregated by type/region) before emitting in the `WebBundle`.

3. **Incorporate `Driver` information:**
   - For each `Driver` row:
     - Create or strengthen edges:
       - `parameter (related_params[i]) → driver_factor (factor)` with `weight = contribution`.
       - `driver_factor → summary_metric` (e.g., map factor names to fields in `Summary`).
     - Map `Driver.direction` into `sign`.

### 2.4 Example (Electricity Price in 2035)

Example nodes (simplified):

```txt
param:carbon_price
param:demand_elasticity
agent_type:ElectricityProducer
commodity:electricity
ts:price:electricity:EU:2035
summary:total_emissions
driver:High carbon price
```

Example edges:

```txt
param:carbon_price           --governs-->    agent_type:ElectricityProducer (sign: negative on emissions)
param:demand_elasticity      --influences--> commodity:electricity (sign: negative on demand)
agent_type:ElectricityProducer --feeds-->    ts:price:electricity:EU:2035 (sign: positive on price)
commodity:electricity        --feeds-->      ts:price:electricity:EU:2035 (demand side)
ts:price:electricity:EU:2035 --aggregates_to--> summary:average_prices (weight ≈ share of EU)
param:carbon_price           --influences--> driver:High carbon price
driver:High carbon price     --influences--> summary:total_emissions
```

### 2.5 UI Query: "Which Parameters Feed Into This Output?"

**Workflow:**

1. User clicks on a data point in the Results chart (e.g., electricity price in 2035).
2. UI resolves to the corresponding node id: `ts:price:electricity:EU:2035`.
3. UI queries the graph:
   - Upstream parameters = all `parameter` nodes reachable via reversed edges within 2–3 hops.
   - Sort by combined edge weights.
4. UI shows:
   - A ranked list of parameters with:
     - `label`, `category`, `direction_of_effect`.
     - Explainer text composed from `Driver.explanation` and metadata.
   - A small graph visualization focusing on the selected metric and its top upstream parameters and agents.

---

## 3. Interactive Scenario Design

### 3.1 Goals

- Move from static "Diff / Scenario Levers" views to **interactive "What if?"** exploration.
- Let users:
  - Toggle/change key parameters for selected timesteps.
  - See immediate preview of changed assumptions and expected qualitative impact.
  - Optionally request a new run with the modified scenario.

### 3.2 Data Model: Scenario Levers

Use `ParameterMetadata` as the source of which parameters can be controlled (`ui.is_scenario_lever`). Define an optional **Scenario Lever** structure for the front-end:

```ts
export interface ScenarioLever {
  param_id: string;               // matches ParameterMetadata.id and AssumptionRow.param
  label: string;
  category: ParamCategory;
  unit: string;
  dimensions: Array<'region' | 'sector' | 'tech' | 'year'>;
  default_scope?: ParameterMetadata['default_scope'];
  slider?: NonNullable<ParameterMetadata['ui']>['slider'];
  direction_of_effect?: ParameterMetadata['direction_of_effect'];
}
```

No new engine schema is strictly required; levers operate over `ScenarioDiffRow`-like diffs.

### 3.3 Editing Scenario Diffs in the UI

A **Scenario Levers** panel in the "Scenario Levers" (formerly Diff) tab:

- Left pane:
  - List of levers grouped by `category` / `ui.group`.
- Right pane:
  - Timestep selector (using `Manifest.years` as the slider bounds).
  - When a lever is selected:
    - A chart showing baseline vs scenario values over time (for that param).
    - Slider or input boxes for changing values for selected years.

The lever interactions manipulate an in-memory **Scenario Patch**:

```ts
export interface ScenarioPatchRow {
  param: string;
  region: string | null;
  sector: string | null;
  tech: string | null;
  year: number | 'all_future';  // helper for "from 2030 onward"
  new_value: number;
}

export type ScenarioPatch = ScenarioPatchRow[];
```

Internally, this can be transformed into `ScenarioDiffRow[]` against the baseline run.

### 3.4 Engine Interaction for Interactive Scenarios

Two levels:

1. **Level 1 – Visual-only / "Dry-run" (no re-run):**
   - UI updates only the **inputs view**:
     - Shows recalculated diffs (`delta`, `delta_pct`) purely at the parameter level.
     - Uses `direction_of_effect` plus dependency graph to show **expected qualitative impact** icons for key outputs (e.g., ↑/↓ for emissions / price).
   - No engine re-run required.

2. **Level 2 – Live runs (optional, advanced):**
   - UI sends a scenario patch to the engine API:

     ```json
     POST /runs
     {
       "base_run_id": "RUN-BASELINE-123",
       "scenario_patch": [
         {
           "param": "carbon_price",
           "region": "EU",
           "year": 2030,
           "new_value": 150
         },
         ...
       ]
     }
     ```

   - Engine:
     - Applies patch on the baseline assumptions.
     - Runs the ABM.
     - Returns a new `WebBundle` for that run (with its own `run_id`, `scenario_id`, etc.).
   - UI:
     - Shows the new run as an overlay in Results (multi-run comparison).
     - Stores the patch for reproducibility (could be persisted in run metadata).

### 3.5 Timestep Handling

- Use `Manifest.years` as the global horizon:
  - Visual timeline slider in the UI for all scenario editing.
- For time-varying params:
  - Provide per-year control or pattern control (e.g., "linear increase from 2025 to 2040").
- Patch helpers:
  - `'all_future'` or ranges like `{ start: 2030, end: 2050 }`, which the engine or UI can expand into concrete years.

---

## 4. Model Documentation Generation

### 4.1 Goals

- Automatically generate documentation for:
  - Parameters
  - Agent types
  - Decision rules
  - Scenario structure
- Ensure docs stay in sync with code/config.

### 4.2 Inputs for Documentation

- **Parameter metadata** (`parameter-metadata.yaml`).
- **Agent type registry** in the engine (e.g., `AgentType` enum and per-type config templates).
- **Decision rules** description:
  - Each decision rule identifier (`AgentConfig.decision_rule`) mapped to:
    - Human-readable name.
    - Description.
    - Parameters used.

### 4.3 Model Docs Schema (Engine Output)

Introduce an optional `ModelDocs` structure that the engine can emit as part of the web bundle (or as a separate file):

```ts
export interface DecisionRuleDoc {
  id: string;                 // matches AgentConfig.decision_rule
  label: string;
  description: string;
  used_params: string[];      // list of ParameterMetadata.id
}

export interface AgentTypeDoc {
  type: AgentType;
  label: string;
  description: string;
  default_params: Record<string, unknown>; // template with comments/types in docs only
  decision_rules: DecisionRuleDoc[];
}

export interface ParameterDoc extends ParameterMetadata {
  examples?: {
    baseline_value?: number;
    scenario_values?: number[];
  };
}

export interface ModelDocs {
  parameters: ParameterDoc[];
  agent_types: AgentTypeDoc[];
  decision_rules: DecisionRuleDoc[]; // for cross-reference
  version: string;
}

export interface WebBundle {
  // existing...
  model_docs?: ModelDocs;
}
```

### 4.4 Generation Pipeline

Implementation sketch (engine side):

1. **Source-of-truth code/metadata:**
   - `parameter-metadata.yaml` for parameters.
   - A small registry for agent types & decision rules, e.g.:

     ```ts
     export const AGENT_TYPE_REGISTRY: AgentTypeDoc[] = [ /* ... */ ];
     export const DECISION_RULE_REGISTRY: DecisionRuleDoc[] = [ /* ... */ ];
     ```

2. **Build script (Node/TS):**
   - Reads YAML and registry.
   - Validates that all `ParameterMetadata.id` used by engine exist.
   - Emits:
     - `docs/model-docs.json` (for web bundle).
     - `docs/model-structure.md` (static docs website).

3. **Web bundle integration:**
   - When exporting a run, include `model_docs` from the latest JSON.

### 4.5 UI Integration

- New tab: **"Model Structure"**:
  - Tree navigation:
    - Agent Types → Decision rules → Parameters they use.
    - Parameters → Agent Types & Decision rules they feed.
  - "View in inputs" button jumps into the Inputs & Assumptions tab and highlights the relevant rows.
- Tooltips/links in other tabs:
  - Inputs: each parameter label links to its documentation entry.
  - Results: clicking "Explain" on a metric shows related parameters and agent types from `ModelDocs` + dependency graph.

---

## 5. Causal Diagram Visualization

### 5.1 Goals

- Provide an **interactive causal diagram** where:
  - Agents, commodities, and metrics are nodes.
  - Flows (energy, hydrogen, money, emissions) and influences are edges.
- Let users visually follow the chain from **policy levers → agent behavior → system outcomes**.

### 5.2 Data Model: Causal Graph

This is a more user-facing, flow-focused subset of the dependency graph.

```ts
export type CausalNodeType =
  | 'agent_type'
  | 'agent_aggregate'
  | 'commodity'
  | 'policy'
  | 'metric';

export type CausalEdgeKind =
  | 'supplies'
  | 'demands'
  | 'emits'
  | 'regulates'
  | 'pays'
  | 'influences';

export interface CausalNode {
  id: string;                   // e.g., "agent:ElectricityProducer:EU"
  type: CausalNodeType;
  label: string;
  meta?: {
    region?: string | null;
    sector?: string | null;
    tech?: string | null;
  };
}

export interface CausalEdge {
  source: string;               // node id
  target: string;               // node id
  kind: CausalEdgeKind;
  sign?: DriverDirection;       // where relevant
  magnitude_by_year?: Record<number, number>; // e.g. TWh, MtCO2, etc.
  unit?: string;
}

export interface CausalGraph {
  nodes: CausalNode[];
  edges: CausalEdge[];
}

export interface WebBundle {
  // existing...
  causal_graph?: CausalGraph;
}
```

### 5.3 Constructing the Causal Graph

Leverage existing data:

- From `AgentConfig`:
  - Create `agent_aggregate` nodes grouped by `(agent_type, region, tech)`.

- From `TimeseriesRow`:
  - Create `commodity` nodes (`commodity:<name>`).
  - For each commodity and year:
    - Determine which agent aggregates mainly supply it (from `agent_traces.state_after.supply` aggregated up).
    - Edge `agent_aggregate → commodity` with `kind: 'supplies'` and `magnitude_by_year[year] = supplied_quantity`.

- From `AgentTraces`:
  - Aggregate:
    - Supply by commodity.
    - Emissions by agent aggregate.
  - Create edges `agent_aggregate → metric:emissions` with `kind: 'emits'`.

- From parameters and policies:
  - Policy parameters with `category: policy` become `policy` nodes:
    - `id = "policy:<param_id>"`.
  - Edges `policy → agent_type` or `policy → agent_aggregate` with `kind: 'regulates'`.

- From `Summary`:
  - Create high-level `metric` nodes (e.g., `metric:total_emissions`, `metric:average_electricity_price`).

### 5.4 UI Mockup Description

**Layout:**

- **Center canvas**: force-directed or layered graph:
  - Commodities in the middle (electricity, hydrogen, etc.).
  - Agent aggregates around them (producers, consumers, regulators).
  - Policy nodes on the left; system metrics on the right.

- **Top**: Year/timestep slider (from `Manifest.years.start` to `.end`).
  - Adjusts edge thickness/opacities based on `magnitude_by_year[year]`.

- **Left sidebar**:
  - Filters:
    - Region(s) (e.g., EU, US, global).
    - Commodity type(s).
    - Node types (agents, policies, metrics).
  - Scenario selector: baseline vs selected scenario runs.

- **Right sidebar**:
  - Details for selected node or edge:
    - Node: type, description, high-level time series summary (sparkline).
    - Edge: magnitude over time, sign, related parameters (link to Inputs tab).
  - "Explain this" button:
    - Opens a mini dependency graph view for the selected metric or commodity.

**Interactions:**

- Clicking a **policy node**:
  - Highlights paths from that policy to key metrics:
    - E.g., carbon price → power producers → electricity price → total emissions.
- Clicking a **metric node**:
  - Back-traces key contributing agents and commodities.

---

## 6. Implementation Phases

The advanced path builds on the simpler path (renamed tabs, timestep indicator, framing of scenario levers). Below is a phased plan with rough scope estimates (S <1d, M 1–3d, L 3–7d, XL >7d, assuming 1–2 devs familiar with the codebase).

### Phase 1: Parameter Metadata Backbone (M)

**Goals:**

- Introduce `parameter-metadata.yaml` and `ParameterMetadata` type.
- Integrate metadata into the web bundle and UI.

**Steps:**

1. Define and validate `parameter-metadata.yaml`:
   - Start with the most important parameters (policy and demand).
   - Implement a small TypeScript schema and validation script.
2. Extend `Manifest.schema_versions` with `parameter_metadata`.
3. Modify export pipeline to optionally include `parameter_metadata` in `WebBundle`.
4. Update Inputs & Assumptions UI:
   - Use `category` and `ui.group` for grouping.
   - Show `label`, `description`, `unit` in the table.
5. Mark initial `is_scenario_lever` parameters for later use.

**Risks / Guardrails:**

- Risk: Metadata drift.  
  Guardrail: Add a CI check ensuring every `AssumptionRow.param` has a corresponding metadata entry (or explicitly marked as "internal").

---

### Phase 2: Dependency Graph MVP (M–L)

**Goals:**

- Implement a basic `DependencyGraph` focusing on static and `Driver`-based edges.

**Steps:**

1. Implement `DependencyGraph` types (shared types between engine + web).
2. Engine:
   - Generate nodes for:
     - `parameter` (from metadata).
     - `agent_type` (from engine registry).
     - Key `timeseries_metric` nodes (e.g., price, emissions per commodity, region, and year, maybe only selected years).
     - `summary_metric` nodes (from `Summary`).
     - `driver_factor` nodes (from `Driver`).
   - Generate edges using:
     - `ParameterMetadata.affected` to connect parameters to agents/outputs.
     - `Driver` to connect parameters to drivers and drivers to summary metrics.
3. Web:
   - Build a simple explorer:
     - In Results tab, "Explain this point" opens a side panel listing related parameters and agents.
     - Use a minimal graph or even a textual path listing in v1.

**Risks / Guardrails:**

- Keep node/edge counts reasonable by:
  - Aggregating agents at type/region/tech level, not per-agent-id.
  - Possibly limiting timeseries metrics to every N years (e.g. 5-year steps) for graph purposes.

---

### Phase 3: Interactive Scenario Levers (M)

**Goals:**

- Add an interactive Scenario Levers UI that edits in-memory scenario patches and diffs.

**Steps:**

1. Derive `ScenarioLever[]` from `ParameterMetadata` (`is_scenario_lever`).
2. Build Scenario Levers panel:
   - Render grouped sliders and controls.
   - When a lever moves:
     - Update `ScenarioPatch`.
     - Recompute a local view of `ScenarioDiff` rows.
3. Update Scenario Levers tab:
   - Show new vs baseline values per year (for the selected lever and scope).
   - Display qualitative impact icons based on `direction_of_effect`.

4. (Optional) Add an API integration for live runs:
   - Define `scenario_patch` request schema.
   - Wire up "Run scenario" button that triggers new run, then navigates to it.

**Risks / Guardrails:**

- Avoid blocking UX on live runs:
  - Keep a clear separation between local/playground patches and persisted runs.
  - Ensure "Reset to baseline" is obvious and fast.

---

### Phase 4: Model Documentation Generation (M)

**Goals:**

- Provide `model_docs` in the bundle and expose a "Model Structure" tab.

**Steps:**

1. Implement `AgentTypeDoc` and `DecisionRuleDoc` registries in the engine.
2. Write a script that:
   - Reads `parameter-metadata.yaml`.
   - Reads engine registries.
   - Produces `model-docs.json` and optionally `model-structure.md`.
3. Integrate `model_docs` into `WebBundle`.
4. In web app:
   - Add "Model Structure" tab.
   - Add links from parameters and decision rules to documentation entries.

**Risks / Guardrails:**

- Keep documentation brief but accurate; avoid over-promising precision where model simplifications exist.
- Add a docs version number and display it in the UI.

---

### Phase 5: Causal Diagram Visualization (L–XL)

**Goals:**

- Implement an interactive causal graph for flows and influences.

**Steps:**

1. Implement `CausalGraph` schema in engine and web.
2. Engine:
   - Aggregate agents into `agent_aggregate` nodes.
   - Derive edges from `AgentTraces` and `Timeseries`:
     - Supply flows, emissions flows.
     - Policy influences from parameter metadata.
3. Web:
   - Use a graph visualization library (or D3) to render:
     - Nodes (agents, commodities, policies, metrics).
     - Edge thickness by magnitude for selected year.
   - Coordinate timeline slider with `Manifest.years`.
   - Add side panel details and filters.

4. Integrate with Dependency Graph:
   - From a causal node/metric, allow "View dependency graph" or "Explain this" to jump to the textual explanation / dependency explorer.

**Risks / Guardrails:**

- Performance: graphs can get large.
  - Start with a small subset (e.g., only electricity sector, EU region).
  - Lazy-load or cluster nodes when many are present.
- Visual complexity:
  - Provide strong filters and defaults (e.g., start with just producers and main commodities).

---

## 7. When to Consider a More Advanced Path

Revisit and expand these designs when:

- Users need **formal sensitivity analysis** (requiring edge weights derived from perturbation runs).
- There is a need for **uncertainty propagation** visualization, not just point estimates.
- Scenario design needs **optimization** or **multi-objective search** over levers, rather than manual "what-if" exploration.

At that point, the parameter metadata, dependency graph, and causal diagram defined here provide a strong foundation for building those advanced capabilities.
